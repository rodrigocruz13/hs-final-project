#!/usr/bin/python3

import json
import re
import requests
import sys

now_stamp = __import__('os_functions').now_stamp


def validate_domain(web_address):
    """ 
    Purpose:   Function that queries a web address to validate connection.
    Arguments: - web_address (str): url to check.
    Returns:   - A URL in correct format if available connection
               - None if no connection available.
    """

    url = web_address
    if (web_address[-1] != '/'):
        url = url + '/'

    try:
        url_request = requests.get(url).text
        return (url)
    except requests.exceptions.RequestException as err:
        return (None)


def get_link_list(fixed_url):
    """ 
    Purpose:   Gets all the valid and unique links from a fixed url.
    Arguments: - fixed_url (str): Web address used to find the links.
    Returns:   - unique_links (list): A list of unique links (str) of the URL.
    """

    print('URL:\t\t{}'.format(fixed_url))
    html_response = requests.get(fixed_url).text

    links_regex = re.compile('<a\s+.*href=[\'"]?([^\'" >]+)', re.IGNORECASE)
    original_links = links_regex.findall(html_response)
    original_links.sort()

    unique_links = []
    for link in original_links:
        full_url = re.sub(r'^\.?/{1,2}', fixed_url, link, count=1)

        cid = full_url.find('?cid')
        if (cid != -1):
            full_url = full_url[0:cid]

        disq = full_url.find('#disqus_thread')
        if (disq != -1):
            full_url = full_url[0:disq]

        numb = full_url.find('#')
        if (numb != -1):
            full_url = full_url[0:numb]

        quest = full_url.find('?')
        if (quest != -1):
            full_url = full_url[0:quest]

        java = full_url.find('javascript:void(0)')
        http = full_url.find('http')
        brac = full_url.find('{')
        mail = full_url.find('mailto:')

        repeat = 1
        if (full_url not in unique_links):
            repeat = - 1

        if (java == -1 and http != -1 and brac == -1 and mail == -1 and repeat == -1):
            unique_links.append(full_url)

    unique_links.sort()
    return(unique_links)


def check_all(url, link_list):
    """ 
    Purpose:   Checks the code status of each link.
               Saves the result in a JSON file 
    Arguments: - url
               - link_list (List): List with all the links from a web address.
    Returns:   - status_dict (Dict): Dict with info generated by checking process.
    """

    status_dict = {}
    list_len = len(link_list)
    print('Links found:\t{}'.format(list_len))

    codes_dict = load_dict_from_file('_status_codes')

    i = 0
    error_dict = {}

    for link in link_list:
        code = 999
        try:
            code = requests.get(link).status_code
        except:
            sys.stdout.flush()

        class_code = codes_dict[str(int(code / 100))]
        explain_code = codes_dict[str(code)]

        status_dict_i = {}
        status_dict_i.update({"Code": str(code)})
        status_dict_i.update({"Type": class_code})
        status_dict_i.update({"Meaning": explain_code})

        check_dict_i = {}
        id = "Check" + ' ' + str(i + 1).zfill(3)
        check_dict_i.update({"Date": str(now_stamp())})
        check_dict_i.update({"Link": link})
        check_dict_i.update({"Status": status_dict_i})

        status_dict.setdefault(id, check_dict_i)

        if (code > 299):
            error_dict.setdefault(id, check_dict_i)

        i += 1
        print_progress_bar(i, list_len, 'Checking:')

    colon = url.find(":") + 3
    basename = url[colon: -1]
    save_dict_to_file(status_dict, basename)
    error_name = basename + '--error_dict'
    save_dict_to_file(error_dict, error_name)

    return(basename)


def print_results(result_filename):
    """ 
    Purpose:   Print the results from the result file.
    Arguments: - url (str): Url domain.
               - status_dict (Dict): Dict generated by the checking process.
    Returns:   - Nothing
    """

    a_dict = load_dict_from_file(result_filename)
    dict_lenght = len(a_dict)
    if (dict_lenght == 0 or a_dict == None):
        print('\nNo problems found')
        exit(1)

    print('\n{} checks done\n'.format(dict_lenght))
    opt = print_menu_results(result_filename)
    return (opt)


def print_board(basename):
    """
    Purpose:   Print a board with the results.
    Arguments: - basename (str): name to use when saving the error dict.
    Returns:   - Nothing.
    """

    a_dict = load_dict_from_file(basename)

    i = 0
    dash = '-' * 175

    for k in a_dict:

        error = basename.find('error')
        if (error == -1):
            id_check = "Check" + ' ' + str(i + 1).zfill(3)
        else:
            id_check = k

        v_check_dict_i = a_dict[id_check]
        link_i = v_check_dict_i['Link']
        date_i = v_check_dict_i['Date']
        status_i_dict = v_check_dict_i['Status']
        code_i = int(status_i_dict['Code'])
        meaning_i = status_i_dict['Meaning']
        type_i = status_i_dict['Type']

        #print(v_check_dict_i, link_i, date_i, status_i_dict, code_i, meaning_i, type_i)

        if (i == 0):
            print(dash)
            print(' {:^6s}{:^16s}{:^28}{:<108s}'.format(
                'Status', 'Type', 'Date', 'Link'))
            print(dash)

        if(code_i < 300):
            print(' {:^6d}{:^16s}{:<28s}{:<112s}'.format(
                code_i, type_i, date_i, link_i))

        else:
            code_i = ' \x1b[1;31;40m' + str(code_i) + '\x1b[0m  '
            type_i = '  \x1b[1;31;40m' + type_i + '\x1b[0m  '
            print(' {:^6s}{:^16s}{:<28s}{:<104s}'.format(
                code_i, type_i, date_i, link_i))
        i += 1


def print_menu_results(result_filename):
    """
    Purpose:   Print a menu to select how to show results.
    Arguments: - None.
    Returns:   - option (char): The option selecter by the user.
    """
    clear_screen = __import__('os_functions').clear_screen

    opt = ''
    while (opt != 'R' or opt != 'r' or opt != 'A' or opt != 'a'):
        print('\t------------------------------------')
        print('\tPrint all the results: (A)')
        print('\tPrint a resume of the errors: (R)')
        print('\tGo back: (B)')
        print('\tQuit: (Q)')
        print('\t------------------------------------')
        opt = input('\tType your choise and hit enter: [ ]\b\b')

        if (opt == 'r' or opt == 'R'):
            print_board(result_filename + '--error_dict')

        if (opt == 'a' or opt == 'A'):
            print_board(result_filename)
        
        if (opt == 'q' or opt == 'Q'):
            clear_screen()
            exit(1)

        if (opt == 'b' or opt == 'b'):
            return opt


def save_dict_to_file(dict, name):
    """
    Purpose:   Saves a "dict" into a JSON file with the "name" provided.
    Arguments: - Dict (Dict): Dict generated by the checking process.
    Returns:   - Nothing.
    """
    path = 'filestorage/'

    slash = name.find('/')
    if (slash != -1):
        name = name[0:slash]

    filename = path + name + '.json'
    f = open(filename, 'w')
    objects = json.dumps(dict, indent=4, skipkeys=True, sort_keys=True)
    f.write(objects)
    f.close()


def load_dict_from_file(name):
    """
    Purpose:   Gets a "dict" from a JSON file with the "name" provided.
    Arguments: - name (str): Name of the JSON file.
    Returns:   - dict (dict): dictionary object.
    """
    path = 'filestorage/'
    filename = path + name + '.json'
    f = open(filename, 'r')
    data = f.read()
    dict = json.loads(data)
    f.close()
    return (dict)


def print_progress_bar(count, total, status=''):
    """
    Purpose:   Prints a progress bar while checking the links.
    Arguments: - count (int): Counter of iterations.
               - total (int): Max number of iterations.
               - status (str): Text to be show while executing.
    Returns:   - Nothing.

    source: https://gist.github.com/vladignatyev/06860ec2040cb497f0f3
    Author: Vladimir Ignatyev
    """

    bar_len = 50
    filled_len = int(round(bar_len * count / float(total)))
    percents = round(100.0 * count / float(total), 1)
    mark = '■'
    bar = mark * filled_len + '∙' * (bar_len - filled_len)
    sys.stdout.write('%s\t[%s] %s%s\r' % (status, bar, percents, '%'))
    sys.stdout.flush()
